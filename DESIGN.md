We decided to use Flask, Werkzeug, FlaskSocketIO, SQLITE3, and other helper packages in our final implementation. We used Flask because of its lightweight nature, its powerful routing capabilities (which can provide numerous unique user experiences in a single app.py file), and because supports the use of Jinja to simplify the process of making new HTML pages. We used Werkzeug because it provided a powerful yet lightweight way to manage user authentication of our site. Instead of storing passwords verbatim, we used Werkzeug's "generate hash" and "check hash" functions to check if a user was properly logged in. By doing this, we prevented to possibility for SQL-injection attacks which could have compromised people's personal data. 

To build the main architecture of our site, we divided our website into two layers. First, we created a base template for all pages on our site (called base.html). This boilerplate template contained critical parts of the site such as the navigation bar and footer, which would be present on all parts of our site. Having a base template allowed us to leverage the power of Jinja, which allows us to seamlessly create new HTML pages from this single template. In our second layer, we used Jinja and HTML to create the other HTML pages such as the guest homepage and user landing page. The development of these pages was heavily expedited thanks to the usage of Jinja. 

We also used SQLITE 3 to store relevant user data, such as their username, password (in hash form), cash present, account age, and more. We decided to use SQLITE3 instead of the CS50 library because while the CS50 library provided an easier way to add tables and view our database, we wanted to use a package that is more commonly used in the real world. By combining the power of SQLITE3 and Flask, we were able to implement advanced features such as viewing other people's betting positions on the game and active tracking how much money a person placed on bets.

In terms of coding implementation, we decided to use VSCode, Github, and Conda Environments to familiarize ourselves with the tools used in the real-world to develop software, improve version control and avoid having code conflicts, and to modularize the packages we install (like Werkzeug and SQLITE3) to prevent them from overwriting package versions in our base environment. Each of these design choices was carefully debated and selected to ensure that our implementation of the project went smoothly.
